import{_ as p}from"./plugin-vueexport-helper-DlAUqK2U.js";import{o as e,c as o,a}from"./index-DHzmZQKC.js";const t=""+new URL("../svg/framework.svg",import.meta.url).href,s={},r=a('<h1>架构示意图</h1><p>H5 与 微信/支付宝小程序 大致的交互示例图如下。</p><p>对于其他的各类小程序、客户端，保持 H5 与 微信/支付宝小程序相同的交互方式即可。</p><p> H5、小程序通过使用独立搭建的前端基建中的组件库、方法库、桥接库、前端规范，提高了开发效率，增强了项目的可维护性。 </p><img src="'+t+'"><h1>架构设计</h1><p>对小程序、h5&amp;小程序交互 的各处关键点进行了设计，可以提供安全高效的架构。</p><h2>一：小程序</h2><p>1：响应式数据设计</p><p> 场景：在小程序中，并未提供类似于pinia的官方库。网上有类似的三方库，不过对页面的结构破坏有点大，并不想采用这种方式。所以，自行实现了状态管理功能，当层级较深时，能够方便的进行响应式更新。 </p><p>方案：</p><p>1）使用proxy对数据对象进行代理。</p><p> 2）在页面的created生命周期中，给当前页面注入一个globalDataProxy属性，表示响应式数据。再注入一个onGlobalDataChange函数，当proxy数据改变时，会触发此函数。在detached生命周期中，删除此事件。 </p><p> 3）将步骤2中的内容，封装为Behavior，需要使用时，可方便的通过behaviors进行注入，使用相关功能。 </p><p>应用：</p><p>可参考微信小程序的源码，在behaviors/store/index.ts便是相关实现</p><p>2：js-sdk</p><p>注意：微信小程序注册js-sdk时，需要用微信公众号的appid等信息，而非小程序的appid。</p><h2>二：h5 &amp; 小程序</h2><p>1：h5与小程序的数据交互</p><p> 问题：最好是能够实时交互，但是微信小程序通过web-view调用h5页面，不支持实时交互，仅在小程序后退、组件销毁时postMessage才起作用。 </p><p>方案：</p><p> 小程序给H5传值时，通过在url后面拼接参数。H5通过postMessage，在退出h5项目时触发。为保证交互的统一性，无论h5与小程序交互，还是与客户端交互时，都应按照这种方式。 </p><p> 小程序与H5需要共享的数据，在小程序和H5项目中，数据结构和内容都应该一致。方便小程序与H5各自项目中内容的更新和维护。 </p><p>举例：</p><p> 可参考微信小程序的源码，在pages/web-view-h5/index.ts中，是小程序给H5传值的实现，会统一将小程序和H5需要共享的数据进行拼接，传递给H5，H5在入口处会对响应式数据进行解析和赋值 </p><p> 可参考H5的源码，在store/module/app/index.ts中，是H5给小程序传值的实现。通过监听响应式数据globalData，在改变时会调用postMessage给小程序传值，小程序在收到更新事件后，适时进行响应式数据更新。 </p><p>2：从小程序返回到H5的处理</p><p> 场景：H5会有需要跳转到小程序的场景，如进行合同签署等情况，当合同签署完成后，为了保证路由的准确性，只能通过navigateBack返回到原有页面，这时，h5需要监听到相关的返回事件，进行数据更新或跳转等功能。 </p><p> 方案：通过监听visibilitychange事件，当从小程序返回或者从后台返回时，能够及时触发，将此功能封装为一个hook函数，使用时很方便。 </p><p>举例：在H5源码的hook/use-back-from-native-or-toggle/index.ts是相关实现，可进行参考。</p><p>3：h5监听侧滑或点击返回按钮的处理</p><p> 场景：存在在某个H5页面，点击返回时需要跳转到特定页面，而非返回在路由堆栈的上一级页面的场景。 </p><p> 方案：通过监听popstate事件，能知道是否是进行了路由返回的操作。增加一个router.beforeEach的钩子函数，在返回时跳执行相关操作。可将次功能封装为一个hook函数，方便使用 </p><p>举例：在H5源码的hook/use-router-back/index.ts是相关实现，可进行参考。</p><p>4：url传参</p><p> 场景：url的参数中可能包含特殊字符，需要进行加密。有的软件会自动进行一次解密，只加密一次并不稳妥。 </p><p> 方案：对url中的参数先进行字符串格式化，再进行两次加密。获取数据依次进行解密和反转。此内容已被集成到自己的方法库中，可方便的使用 </p><p>5：localStorage</p><p>场景：</p><p> 不同的项目可能在同一个域名下，有些内容是相同的，比如token，会导致打开不同项目后，数据会被错误的更新。 </p><p>原生的localStorage.setItem设置undefined的数据会报错。</p><p>H5刷新页面时如何保证状态不丢失，可正常打开各个页面。</p><p>方案：</p><p>不同的项目，放在localStorage的不同名字下。</p><p>进行setItem等操作前进行判断。如果有undefined的数据，不进行setItem。</p><p>相关内容已集成在我的方法库中，可方便的进行使用。</p><p> 跳转到H5时，需传递好需要同步的相关数据，并将内容存储到localStorage中，即使刷新，也能够从localStorage中拿到相关数据，展示页面。页面在热加载时能够快速更新效果。 </p>',48),i=[r];function h(n,c){return e(),o("div",null,i)}const H=p(s,[["render",h]]);export{H as default};
